"""
Composants d'interface utilisateur r√©utilisables.
"""
import streamlit as st
from typing import Dict, Any

from config.constants import (
    Gender, Country, Category, BinaryChoice, VALIDATION_RANGES
)


class InputComponents:
    """Classe contenant les composants d'entr√©e Streamlit."""
    
    @staticmethod
    def render_numeric_input(
        label: str, 
        field_name: str, 
        help_text: str = None
    ) -> float:
        """
        Affiche un input num√©rique avec validation.
        
        Args:
            label: Label affich√©
            field_name: Nom du champ pour la validation
            help_text: Texte d'aide optionnel
            
        Returns:
            Valeur saisie
        """
        config = VALIDATION_RANGES[field_name]
        
        if field_name in ["balance", "estimated_salary"]:
            return st.number_input(
                label,
                min_value=config["min"],
                max_value=config["max"],
                value=config["default"],
                step=1000.0,
                help=help_text
            )
        else:
            return st.number_input(
                label,
                min_value=int(config["min"]),
                max_value=int(config["max"]),
                value=int(config["default"]),
                help=help_text
            )
    
    @staticmethod
    def render_slider_input(
        label: str, 
        field_name: str, 
        help_text: str = None
    ) -> int:
        """
        Affiche un slider avec validation.
        
        Args:
            label: Label affich√©
            field_name: Nom du champ pour la validation
            help_text: Texte d'aide optionnel
            
        Returns:
            Valeur s√©lectionn√©e
        """
        config = VALIDATION_RANGES[field_name]
        
        return st.slider(
            label,
            min_value=int(config["min"]),
            max_value=int(config["max"]),
            value=int(config["default"]),
            help=help_text
        )
    
    @staticmethod
    def render_selectbox(
        label: str, 
        enum_class, 
        help_text: str = None
    ):
        """
        Affiche une selectbox pour une √©num√©ration.
        
        Args:
            label: Label affich√©
            enum_class: Classe d'√©num√©ration
            help_text: Texte d'aide optionnel
            
        Returns:
            Valeur s√©lectionn√©e
        """
        options = [e.value for e in enum_class]
        selected_value = st.selectbox(label, options, help=help_text)
        
        # Retourne l'enum correspondant
        for enum_item in enum_class:
            if enum_item.value == selected_value:
                return enum_item
        
        return list(enum_class)[0]  # Fallback


class DisplayComponents:
    """Classe contenant les composants d'affichage."""
    
    @staticmethod
    def render_prediction_result(result, customer_data):
        """
        Affiche le r√©sultat de pr√©diction de mani√®re format√©e.
        
        Args:
            result: R√©sultat de la pr√©diction
            customer_data: Donn√©es du client
        """
        # Conteneur principal
        st.markdown("---")
        st.subheader("üéØ R√©sultat de la Pr√©diction")
        
        # Colonnes pour l'affichage
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if result.will_churn:
                st.error(f"‚ö†Ô∏è **Risque de D√©part**")
            else:
                st.success(f"‚úÖ **Client Fid√®le**")
        
        with col2:
            st.metric(
                "Probabilit√© de Churn",
                result.formatted_probability,
                delta=None
            )
        
        with col3:
            risk_color = {
                "Faible": "üü¢",
                "Moyen": "üü°", 
                "√âlev√©": "üî¥"
            }
            st.metric(
                "Niveau de Risque",
                f"{risk_color.get(result.risk_level, '‚ö™')} {result.risk_level}"
            )
        
        # Message d√©taill√©
        st.markdown("### üí¨ Interpr√©tation")
        if result.will_churn:
            st.warning(
                f"Ce client pr√©sente un **risque {result.risk_level.lower()}** de churn "
                f"avec une probabilit√© de {result.formatted_probability}. "
                f"Il est recommand√© de mettre en place des actions de r√©tention."
            )
        else:
            st.info(
                f"Ce client a une **faible probabilit√©** de churn "
                f"({result.formatted_probability}). Il s'agit d'un client fid√®le "
                f"avec un risque {result.risk_level.lower()}."
            )
    
    @staticmethod
    def render_customer_summary(customer_data):
        """
        Affiche un r√©sum√© des donn√©es client.
        
        Args:
            customer_data: Donn√©es du client
        """
        st.subheader("üë§ Profil Client")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Informations D√©mographiques**")
            st.write(f"‚Ä¢ √Çge : {customer_data.age} ans")
            st.write(f"‚Ä¢ Sexe : {customer_data.gender.value}")
            st.write(f"‚Ä¢ Pays : {customer_data.country.value}")
            st.write(f"‚Ä¢ Cat√©gorie : {customer_data.category.value}")
        
        with col2:
            st.write("**Informations Financi√®res**")
            st.write(f"‚Ä¢ Score de cr√©dit : {customer_data.credit_score}")
            st.write(f"‚Ä¢ Solde : {customer_data.balance:,.0f} ‚Ç¨")
            st.write(f"‚Ä¢ Salaire estim√© : {customer_data.estimated_salary:,.0f} ‚Ç¨")
            st.write(f"‚Ä¢ Nombre de produits : {customer_data.num_of_products}")
    
    @staticmethod
    def render_error_message(errors: list):
        """
        Affiche les messages d'erreur de validation.
        
        Args:
            errors: Liste des erreurs
        """
        if errors:
            st.error("‚ùå **Erreurs de validation d√©tect√©es :**")
            for error in errors:
                st.error(f"‚Ä¢ {error}")
            return True
        return False
